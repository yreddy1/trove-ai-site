<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Trove-AI | About</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Learn about Trove-AI's mission, values, and commitment to trusted AI." />

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />

  <link rel="stylesheet" href="./dist/output.css" />

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Markdown Styles for Chat */
    .markdown-body strong { font-weight: 700; color: white; }
    .markdown-body p { margin-bottom: 0.5rem; }
    .markdown-body p:last-child { margin-bottom: 0; }
    .markdown-body ul, .markdown-body ol { margin-left: 1.25rem; list-style-type: disc; margin-bottom: 0.5rem; }
    .markdown-body li { margin-bottom: 0.25rem; }

    /* Data Flow Background */
    .data-flow-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.7;
    }
    @media (prefers-reduced-motion: reduce) {
      .data-flow-canvas { display: none; }
    }
    .page-enter,
    .page-exit {
      opacity: 0;
      transform: translateY(8px);
    }
    @media (prefers-reduced-motion: reduce) {
      #page-content {
        transition: none !important;
        opacity: 1 !important;
        transform: none !important;
      }
      .page-enter,
      .page-exit {
        opacity: 1 !important;
        transform: none !important;
      }
    }
  </style>
</head>
<body class="min-h-screen bg-trove-dark font-sans text-slate-300 antialiased">
  <div class="fixed inset-0 z-0 pointer-events-none overflow-hidden">
    <canvas id="data-flow" class="data-flow-canvas"></canvas>
  </div>
  <div
    id="frequency-label"
    class="pointer-events-none fixed left-6 top-1/2 -translate-y-1/2 text-[10px] uppercase tracking-[0.2em] text-slate-500 opacity-70 font-mono"
    aria-hidden="true"
  >
    <div>Signal Freq</div>
    <div data-freq-value class="mt-1 text-[10px] text-slate-400 tracking-normal">--</div>
  </div>
  <!-- HEADER -->
  <header class="sticky top-0 z-40 border-b border-white/10 bg-trove-dark">
    <div class="mx-auto flex max-w-6xl items-center justify-between px-6 py-4">
      <a href="./index.html" class="block">
        <img src="./Trove_Logo.png" alt="Trove AI" class="h-8 w-auto" />
      </a>
      <nav class="flex gap-6 text-sm font-medium text-slate-400">
        <a href="./index.html" class="hover:text-white">Home</a>
        <a href="./about.html" class="text-white">About</a>
        <a href="./solutions.html" class="hover:text-white">Solutions</a>
        <a href="./contact.html" class="hover:text-white">Contact</a>
      </nav>
    </div>
  </header>

  <main id="page-content" class="relative z-10 transition-opacity transition-transform duration-200 ease-out">
    <!-- HERO -->
    <section class="mx-auto max-w-6xl px-6 pb-16 pt-20">
      <div class="space-y-6">
        <h1 class="text-4xl font-semibold leading-tight text-white md:text-5xl">
          Our Mission: Turning Data into Decisions, and Decisions into Trust
        </h1>
        <p class="max-w-3xl text-lg text-slate-400">
          At Trove, we build AI solutions that protect people, enhance security, and empower organizations to act with clarity and confidence.
        </p>
      </div>
    </section>

    <!-- COMPANY OVERVIEW -->
    <section class="mx-auto max-w-6xl px-6 pb-16">
      <div class="rounded-2xl border border-white/10 bg-white/5 p-8 shadow-sm">
        <h2 class="text-2xl font-semibold text-white">Company Overview</h2>
        <p class="mt-4 text-sm text-slate-400">
          Trove was founded on the belief that trustworthy AI must be practical, accountable, and aligned to the realities of mission-critical operations. We focus on safety, trust, and readiness by delivering systems that strengthen situational awareness, support compliance, and help teams act with confidence.
        </p>
      </div>
    </section>

    <!-- TROVE TEAM -->
    <section class="mx-auto max-w-6xl px-6 pb-16">
      <div class="rounded-2xl border border-white/10 bg-white/5 p-8 shadow-sm">
        <h2 class="text-2xl font-semibold text-white">The Trove Team</h2>
        <p class="mt-4 text-sm text-slate-400">
          Our team brings decades of experience across defense, technology, and enterprise operations, with a shared commitment to delivering AI that performs in the field and earns trust over time.
        </p>
      </div>
    </section>

    <!-- VALUES -->
    <section class="mx-auto max-w-6xl px-6 pb-16">
      <div class="flex flex-col gap-3">
        <p class="text-xs uppercase tracking-[0.2em] text-trove-lime">Our Values</p>
        <h2 class="text-3xl font-semibold text-white">Guided by principles that endure</h2>
      </div>
      <div class="mt-8 grid gap-6 md:grid-cols-2 lg:grid-cols-4">
        <div class="rounded-2xl border border-white/10 bg-white/5 p-6 shadow-sm">
          <h3 class="text-lg font-semibold text-white">Innovation</h3>
          <p class="mt-2 text-sm text-slate-400">Purpose-built AI that delivers real-world outcomes.</p>
        </div>
        <div class="rounded-2xl border border-white/10 bg-white/5 p-6 shadow-sm">
          <h3 class="text-lg font-semibold text-white">Integrity</h3>
          <p class="mt-2 text-sm text-slate-400">Security, compliance, and ethical design in every deployment.</p>
        </div>
        <div class="rounded-2xl border border-white/10 bg-white/5 p-6 shadow-sm">
          <h3 class="text-lg font-semibold text-white">Impact</h3>
          <p class="mt-2 text-sm text-slate-400">Measurable safety and operational improvements.</p>
        </div>
        <div class="rounded-2xl border border-white/10 bg-white/5 p-6 shadow-sm">
          <h3 class="text-lg font-semibold text-white">Partnership</h3>
          <p class="mt-2 text-sm text-slate-400">Long-term collaboration with mission owners and operators.</p>
        </div>
      </div>
    </section>

    <!-- CERTIFICATIONS -->
    <section class="mx-auto max-w-6xl px-6 pb-16">
      <div class="rounded-2xl border border-white/10 bg-white/5 p-8 shadow-sm">
        <h2 class="text-2xl font-semibold text-white">Certifications &amp; Compliance</h2>
        <p class="mt-4 text-sm text-slate-400">
          Trove products are designed with compliance-first architecture, aligned to security standards, governance frameworks, and rigorous risk management practices required in government and enterprise environments.
        </p>
      </div>
    </section>

    <!-- CLOSING CTA -->
    <section class="mx-auto max-w-6xl px-6 pb-20">
      <div class="rounded-2xl border border-white/10 bg-white/5 p-10 shadow-sm">
        <h2 class="text-3xl font-semibold text-white">Explore how Trove is redefining trust and safety with AI.</h2>
        <div class="mt-6">
          <a href="mailto:info@trove-ai.com" class="rounded-lg bg-trove-lime px-5 py-3 text-sm font-semibold text-trove-dark">Contact Us</a>
        </div>
      </div>
    </section>
  </main>

  <!-- FOOTER -->
  <footer class="relative z-10 border-t border-white/10 bg-trove-dark py-8">
    <div class="mx-auto max-w-6xl px-6 text-center text-xs text-slate-500">Â© 2025 Trove-AI</div>
  </footer>
<!-- AI ASSISTANT WIDGET -->
  <div id="ai-assistant-widget" class="fixed bottom-6 left-6 z-50 flex flex-col items-start gap-4">
    
    <!-- Chat Window (Initially Hidden) -->
    <div id="ai-chat-window" class="hidden w-80 overflow-hidden rounded-2xl border border-white/10 bg-trove-dark/90 text-sm shadow-2xl backdrop-blur-md transition-all">
      <!-- Header -->
      <div class="flex items-center justify-between bg-white/5 px-4 py-3 border-b border-white/5">
        <div class="flex items-center gap-3">
            <div class="relative">
              <img src="./greta.jpg" alt="Greta" class="h-8 w-8 rounded-full object-cover border border-white/10" />
              <span class="absolute -bottom-0.5 -right-0.5 h-2.5 w-2.5 rounded-full bg-trove-lime ring-2 ring-trove-dark animate-pulse"></span>
            </div>
            <div>
              <div class="text-sm font-semibold text-white">Greta</div>
              <div class="text-[10px] uppercase tracking-[0.2em] text-slate-400">Trove AI Guide</div>
            </div>
        </div>
        <div class="flex items-center gap-2">
            <!-- Mute Toggle -->
            <button id="mute-btn" onclick="toggleMute()" class="text-trove-lime hover:text-white transition-colors" title="Toggle Voice Response">
                <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>
            </button>
            <button onclick="toggleAssistant()" class="text-slate-400 hover:text-white">
                <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
            </button>
        </div>
      </div>

      <!-- Messages Area -->
      <div id="ai-messages" class="h-64 overflow-y-auto p-4 space-y-4 scrollbar-thin scrollbar-thumb-white/10">
        <!-- Initial Message -->
        <div class="flex gap-3">
            <div class="h-8 w-8 shrink-0 rounded-full bg-trove-lime/20 flex items-center justify-center text-trove-lime">
                <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" /></svg>
            </div>
            <div class="rounded-2xl rounded-tl-none bg-white/5 p-3 text-slate-300">
                Hello. I can help you navigate our solutions or answer questions about Trove's capabilities. What would you like to know?
            </div>
        </div>
      </div>

      <!-- Input Area -->
      <div class="border-t border-white/5 bg-white/5 p-3">
        <div class="flex items-center gap-2 rounded-lg bg-trove-dark/50 px-3 py-2 border border-white/10 focus-within:border-trove-lime/50 transition-colors">
            <input type="text" id="ai-input" placeholder="Type or speak..." class="w-full bg-transparent text-white placeholder-slate-500 focus:outline-none" onkeypress="handleKeyPress(event)">
            <button id="mic-btn" onclick="toggleSpeech()" class="text-slate-400 hover:text-trove-lime transition-colors">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>
            </button>
            <button onclick="sendMessage()" class="text-trove-lime hover:text-white transition-colors">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /></svg>
            </button>
        </div>
      </div>
    </div>

    <!-- Toggle Button -->
    <button onclick="toggleAssistant()" class="group relative flex h-14 w-14 items-center justify-center rounded-full bg-trove-lime text-trove-dark shadow-lg shadow-trove-lime/20 transition-all hover:scale-110 hover:shadow-trove-lime/40">
        <span class="absolute -top-1 -right-1 flex h-4 w-4">
          <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-white opacity-75"></span>
          <span class="relative inline-flex rounded-full h-4 w-4 bg-red-500 border-2 border-trove-dark"></span>
        </span>
        <svg class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" /></svg>
    </button>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById('data-flow');
      if (!canvas) return;

      const freqLabel = document.getElementById('frequency-label');
      const freqValue = freqLabel ? freqLabel.querySelector('[data-freq-value]') : null;

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) {
        if (freqLabel) freqLabel.style.display = 'none';
        return;
      }

      const ctx = canvas.getContext('2d');
      let width = 0;
      let height = 0;
      let dpr = 1;
      let particles = [];
      let lastShapeKind = null;
      let nextShapeAt = 0;
      let lastTime = 0;
      let trovePoints = null;
      let troveAspect = 1;

      const shapeKinds = ['circle', 'hex', 'wave', 'grid', 'triangle', 'freq', 'trove', 'freq', 'harmonic'];
      let freqDrift = Math.random() * 10;
      let baseFrequency = 2.4 + Math.random() * 4.8;

      function resize() {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = Math.max(1, Math.floor(width * dpr));
        canvas.height = Math.max(1, Math.floor(height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function createParticles() {
        const count = width < 720 ? 110 : 190;
        particles = Array.from({ length: count }, () => ({
          x: Math.random() * width,
          y: Math.random() * height,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          tx: Math.random() * width,
          ty: Math.random() * height,
          jitter: 0.3 + Math.random() * 0.6
        }));
        assignTargets();
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function nextFrequency() {
        freqDrift += 0.3 + Math.random() * 0.7;
        baseFrequency = 1.8 + (freqDrift % 7.6) + Math.random() * 0.3;
        return baseFrequency;
      }

      function randomFreqShape() {
        const f = nextFrequency();
        return {
          type: 'freq',
          f,
          phase: Math.random() * Math.PI * 2,
          scale: 0.7 + Math.random() * 0.6
        };
      }

      function randomHarmonicShape() {
        const f = nextFrequency();
        return {
          type: 'harmonic',
          f,
          phase: [
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 2
          ],
          scale: 0.65 + Math.random() * 0.7
        };
      }

      function getShapeDescriptor(kind) {
        if (kind === 'freq') return randomFreqShape();
        if (kind === 'harmonic') return randomHarmonicShape();
        if (kind === 'trove') return { type: 'trove' };
        return kind;
      }

      function generatePoints(shape, count) {
        const cx = width * 0.5;
        const cy = height * 0.5;
        const size = Math.min(width, height) * 0.28;
        const points = [];

        if (shape && typeof shape === 'object' && shape.type === 'trove' && Array.isArray(trovePoints)) {
          const points = [];
          const scale = size * 1.05;
          const aspect = troveAspect || 1;
          for (let i = 0; i < count; i += 1) {
            const sample = trovePoints[i % trovePoints.length];
            points.push({
              x: cx + (sample.x - 0.5) * scale * aspect,
              y: cy + (sample.y - 0.5) * scale
            });
          }
          return points;
        }

        if (shape && typeof shape === 'object' && shape.type === 'freq') {
          const total = count;
          for (let i = 0; i < total; i += 1) {
            const t = (i / total) * Math.PI * 2;
            const radial = Math.sin(shape.f * t + shape.phase) * size * 0.65 * shape.scale;
            const x = Math.cos(t) * radial;
            const y = Math.sin(t) * radial * 0.85;
            points.push({ x: cx + x, y: cy + y });
          }
          return points;
        }

        if (shape && typeof shape === 'object' && shape.type === 'harmonic') {
          const total = count;
          for (let i = 0; i < total; i += 1) {
            const t = (i / total) * Math.PI * 2;
            const wave =
              Math.sin(shape.f * t + shape.phase[0]) +
              0.45 * Math.sin(shape.f * t + shape.phase[1]) +
              0.25 * Math.sin(shape.f * t + shape.phase[2]);
            const radial = wave * size * 0.45 * shape.scale;
            const x = Math.cos(t) * radial;
            const y = Math.sin(t) * radial * 0.78;
            points.push({ x: cx + x, y: cy + y });
          }
          return points;
        }

        if (shape === 'circle') {
          for (let i = 0; i < count; i += 1) {
            const angle = (i / count) * Math.PI * 2 + (Math.random() - 0.5) * 0.2;
            const radius = size * (0.4 + Math.random() * 0.6);
            points.push({
              x: cx + Math.cos(angle) * radius,
              y: cy + Math.sin(angle) * radius * 0.85
            });
          }
          return points;
        }

        if (shape === 'hex') {
          const vertices = [];
          for (let i = 0; i < 6; i += 1) {
            const angle = (Math.PI / 3) * i - Math.PI / 6;
            vertices.push({
              x: cx + Math.cos(angle) * size * 1.05,
              y: cy + Math.sin(angle) * size * 0.9
            });
          }
          for (let i = 0; i < count; i += 1) {
            const t = (i / count) * 6;
            const idx = Math.floor(t);
            const local = t - idx;
            const v1 = vertices[idx % 6];
            const v2 = vertices[(idx + 1) % 6];
            points.push({
              x: v1.x + (v2.x - v1.x) * local + (Math.random() - 0.5) * 12,
              y: v1.y + (v2.y - v1.y) * local + (Math.random() - 0.5) * 12
            });
          }
          return points;
        }

        if (shape === 'triangle') {
          const vertices = [
            { x: cx, y: cy - size },
            { x: cx - size * 0.95, y: cy + size * 0.65 },
            { x: cx + size * 0.95, y: cy + size * 0.65 }
          ];
          for (let i = 0; i < count; i += 1) {
            const t = (i / count) * 3;
            const idx = Math.floor(t);
            const local = t - idx;
            const v1 = vertices[idx % 3];
            const v2 = vertices[(idx + 1) % 3];
            points.push({
              x: v1.x + (v2.x - v1.x) * local + (Math.random() - 0.5) * 10,
              y: v1.y + (v2.y - v1.y) * local + (Math.random() - 0.5) * 10
            });
          }
          return points;
        }

        if (shape === 'wave') {
          const waveWidth = size * 2.2;
          const amp = size * 0.35;
          for (let i = 0; i < count; i += 1) {
            const t = i / (count - 1);
            const x = cx - waveWidth / 2 + waveWidth * t;
            const y = cy + Math.sin(t * Math.PI * 4) * amp + Math.sin(t * Math.PI * 8) * amp * 0.4;
            points.push({
              x,
              y
            });
          }
          return points;
        }

        const gridSize = Math.ceil(Math.sqrt(count));
        const gridSpan = size * 1.4;
        const startX = cx - gridSpan / 2;
        const startY = cy - gridSpan / 2;
        const step = gridSpan / Math.max(1, gridSize - 1);
        for (let i = 0; i < count; i += 1) {
          const gx = i % gridSize;
          const gy = Math.floor(i / gridSize);
          points.push({
            x: startX + gx * step + (Math.random() - 0.5) * 8,
            y: startY + gy * step + (Math.random() - 0.5) * 8
          });
        }
        return points;
      }

      function pickNextShapeKind() {
        if (!shapeKinds.length) return 'circle';
        let next = shapeKinds[Math.floor(Math.random() * shapeKinds.length)];
        let attempts = 0;
        while (next === lastShapeKind && attempts < 6) {
          next = shapeKinds[Math.floor(Math.random() * shapeKinds.length)];
          attempts += 1;
        }
        lastShapeKind = next;
        return next;
      }

      let lastFrequencyLabel = baseFrequency;

      function updateFrequencyLabel(shape) {
        if (!freqLabel || !freqValue) return;
        if (shape && typeof shape === 'object' && (shape.type === 'freq' || shape.type === 'harmonic')) {
          lastFrequencyLabel = shape.f;
          freqLabel.style.opacity = '0.7';
          freqValue.textContent = `${shape.f.toFixed(1)} Hz`;
          return;
        }
        if (typeof lastFrequencyLabel === 'number') {
          freqLabel.style.opacity = '0.45';
          freqValue.textContent = `${lastFrequencyLabel.toFixed(1)} Hz`;
        } else {
          freqLabel.style.opacity = '0.45';
          freqValue.textContent = '--';
        }
      }

      let currentShape = getShapeDescriptor(pickNextShapeKind());
      updateFrequencyLabel(currentShape);

      function assignTargets() {
        const points = generatePoints(currentShape, particles.length);
        shuffle(points);
        particles.forEach((particle, index) => {
          const target = points[index % points.length];
          particle.tx = target.x;
          particle.ty = target.y;
          particle.vx += (Math.random() - 0.5) * 3;
          particle.vy += (Math.random() - 0.5) * 3;
          particle.jitter = 0.2 + Math.random() * 0.8;
        });
        nextShapeAt = performance.now() + 8000 + Math.random() * 5000;
      }

      function update(time) {
        const dt = Math.min(40, time - lastTime || 16);
        lastTime = time;

        ctx.clearRect(0, 0, width, height);

        const flowX = Math.sin(time * 0.00035) * 0.35;
        const flowY = Math.cos(time * 0.00028) * 0.28;
        const pull = 0.0026;
        const damping = 0.88;

        for (const particle of particles) {
          const dx = particle.tx - particle.x;
          const dy = particle.ty - particle.y;

          particle.vx += dx * pull + flowX * 0.08 * particle.jitter;
          particle.vy += dy * pull + flowY * 0.08 * particle.jitter;

          particle.vx *= damping;
          particle.vy *= damping;

          particle.x += particle.vx * (dt / 16);
          particle.y += particle.vy * (dt / 16);
        }

        ctx.lineWidth = 1;
        let lineCount = 0;
        for (let i = 0; i < particles.length; i += 1) {
          const p = particles[i];
          for (let j = i + 1; j < particles.length; j += 1) {
            const q = particles[j];
            const dx = p.x - q.x;
            const dy = p.y - q.y;
            const dist2 = dx * dx + dy * dy;
            if (dist2 < 5200) {
              const alpha = 1 - dist2 / 5200;
              ctx.strokeStyle = `rgba(120, 200, 255, ${0.12 * alpha})`;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(q.x, q.y);
              ctx.stroke();
              lineCount += 1;
              if (lineCount > 140) break;
            }
          }
          if (lineCount > 140) break;
        }

        for (const particle of particles) {
          const speed = Math.min(3, Math.hypot(particle.vx, particle.vy));
          ctx.strokeStyle = `rgba(161, 195, 78, ${0.12 + speed * 0.08})`;
          ctx.beginPath();
          ctx.moveTo(particle.x, particle.y);
          ctx.lineTo(particle.x - particle.vx * 6, particle.y - particle.vy * 6);
          ctx.stroke();

          ctx.fillStyle = 'rgba(255, 255, 255, 0.55)';
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, 1.4, 0, Math.PI * 2);
          ctx.fill();
        }

        if (time > nextShapeAt) {
          currentShape = getShapeDescriptor(pickNextShapeKind());
          updateFrequencyLabel(currentShape);
          assignTargets();
        }

        requestAnimationFrame(update);
      }

      resize();
      createParticles();
      loadTrovePoints();
      window.addEventListener('resize', () => {
        resize();
        createParticles();
      });
      requestAnimationFrame(update);

      function loadTrovePoints() {
        const img = new Image();
        img.src = './Trove_Logo.png';
        img.onload = () => {
          const maxSize = 220;
          const scale = Math.min(maxSize / img.width, maxSize / img.height);
          const w = Math.max(1, Math.floor(img.width * scale));
          const h = Math.max(1, Math.floor(img.height * scale));
          const off = document.createElement('canvas');
          off.width = w;
          off.height = h;
          const octx = off.getContext('2d');
          octx.clearRect(0, 0, w, h);
          octx.drawImage(img, 0, 0, w, h);
          const data = octx.getImageData(0, 0, w, h).data;
          const points = [];
          for (let y = 0; y < h; y += 2) {
            for (let x = 0; x < w; x += 2) {
              const idx = (y * w + x) * 4;
              const alpha = data[idx + 3];
              const luminance = 0.2126 * data[idx] + 0.7152 * data[idx + 1] + 0.0722 * data[idx + 2];
              if (alpha > 40 && luminance > 30) {
                points.push({ x: x / w, y: y / h });
              }
            }
          }
          if (points.length > 0) {
            trovePoints = points;
            troveAspect = w / h;
          }
        };
      }
    })();
  </script>

  <script src="./chatbot.js"></script>
  <script>
    (() => {
      const page = document.getElementById('page-content');
      if (!page) return;

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
      if (prefersReducedMotion.matches) {
        page.classList.remove('page-enter', 'page-exit');
        return;
      }

      page.classList.add('page-enter');
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          page.classList.remove('page-enter');
        });
      });

      let isExiting = false;
      document.addEventListener('click', (event) => {
        const link = event.target.closest('a');
        if (!link || isExiting) return;
        if (event.defaultPrevented) return;
        if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
        if (link.target && link.target !== '_self') return;

        const href = link.getAttribute('href');
        if (!href || href.startsWith('#')) return;
        if (href.startsWith('mailto:') || href.startsWith('tel:')) return;
        if (link.hasAttribute('download')) return;

        const url = new URL(href, window.location.href);
        if (url.origin !== window.location.origin) return;

        event.preventDefault();
        isExiting = true;
        page.classList.add('page-exit');
        window.setTimeout(() => {
          window.location.href = url.toString();
        }, 200);
      });
    })();
  </script>

  <audio id="ambient-audio" src="./trove_ai_psy_ambient_138bpm.wav" loop preload="none"></audio>
  <button
    id="ambient-audio-toggle"
    class="fixed bottom-6 right-6 z-50 flex h-12 w-12 items-center justify-center rounded-full border border-white/10 bg-trove-dark/80 text-lg text-slate-200 shadow-lg backdrop-blur transition-colors hover:text-white hover:border-white/20"
    aria-label="Toggle ambient audio"
    aria-pressed="false"
    type="button"
  >ðŸ”‡</button>
  <script>
    (() => {
      const audio = document.getElementById('ambient-audio');
      const button = document.getElementById('ambient-audio-toggle');
      if (!audio || !button) return;

      audio.volume = 0.15;
      let userEnabled = false;
      let pausedByVisibility = false;
      let pausedByAssistant = false;

      const updateIcon = () => {
        button.textContent = userEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
        button.setAttribute('aria-pressed', userEnabled ? 'true' : 'false');
      };

      const playAudio = async () => {
        try {
          await audio.play();
        } catch (error) {
          userEnabled = false;
          updateIcon();
        }
      };

      const pauseAudio = () => {
        audio.pause();
      };

      button.addEventListener('click', () => {
        userEnabled = !userEnabled;
        if (userEnabled) {
          pausedByVisibility = false;
          pausedByAssistant = false;
          playAudio();
        } else {
          pauseAudio();
        }
        updateIcon();
      });

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          if (!audio.paused) {
            pausedByVisibility = true;
            pauseAudio();
          }
          return;
        }
        if (userEnabled && pausedByVisibility && !pausedByAssistant) {
          pausedByVisibility = false;
          playAudio();
        }
      });

      window.pauseAmbientAudio = () => {
        if (!userEnabled) return;
        pausedByAssistant = true;
        pauseAudio();
      };

      window.resumeAmbientAudio = () => {
        if (!userEnabled) return;
        pausedByAssistant = false;
        if (!document.hidden) playAudio();
      };

      updateIcon();
    })();
  </script>
</body>
</html>
